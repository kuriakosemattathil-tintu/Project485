"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var AutoCompleteSearchBar_1 = require("./AutoCompleteSearchBar");
var ListContainer_1 = require("./../common/ListContainer");
var List_1 = require("./../common/List");
var DropDownBase_1 = require("../common/DropDownBase");
var ComboBoxBase_1 = require("../common/ComboBoxBase");
var util_1 = require("../common/util");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var AutoComplete = /** @class */ (function (_super) {
    __extends(AutoComplete, _super);
    function AutoComplete(props) {
        var _this = _super.call(this, props) || this;
        _this._suggested = '';
        /**
         * @hidden
         */
        _this.handleItemSelect = function (index, state) {
            var newText = util_1.getText(_this.props, index);
            var prevText = _this.value;
            _this.setValue(newText);
            if (newText !== prevText) {
                state.events.push({ type: 'onChange' });
            }
        };
        /**
         * @hidden
         */
        _this.itemFocus = function (index, state) {
            state.data.focusedIndex = index;
        };
        /**
         * @hidden
         */
        _this.togglePopup = function (state) {
            _this.combobox.togglePopup(state);
        };
        _this.onChangeHandler = function (event) {
            var dropdown = _this.combobox.dropdown;
            var state = dropdown.initState();
            var input = event.currentTarget;
            var value = input.value;
            var selectionAtEnd = input.selectionEnd === value.length;
            state.syntheticEvent = event;
            var prevSuggestion = _this._suggested;
            var prevValue = _this.value;
            var prevUserInput = prevValue &&
                prevValue.substring(0, prevValue.length - prevSuggestion.length);
            var deletedSuggestion = prevUserInput && prevUserInput === value;
            var deleting = prevUserInput && prevUserInput.length > value.length;
            var suggest = _this.props.suggest;
            if (suggest !== undefined && suggest !== false) {
                if (deletedSuggestion || deleting || !selectionAtEnd) {
                    _this._suggested = '';
                }
                else {
                    _this.suggestValue(value);
                }
                var newValue = value + _this._suggested;
                _this.setValue(newValue);
                var suggestion = { userInput: value, value: _this._suggested };
                state.events.push({ type: 'onChange', suggestion: suggestion });
            }
            else {
                _this._suggested = '';
                _this.setValue(value);
                state.events.push({ type: 'onChange' });
            }
            if (!_this.state.opened && value) {
                state.data.opened = true;
                state.events.push({ type: 'onOpen' });
            }
            else if (_this.state.opened && !value) {
                state.data.opened = false;
                state.events.push({ type: 'onClose' });
            }
            var focusedIndex = _this.getFocusedIndex(value);
            if (_this.state.focusedIndex !== focusedIndex) {
                state.data.focusedIndex = focusedIndex;
            }
            _this.forceUpdateIfNeeded(state);
            dropdown.applyState(state);
        };
        _this.clearButtonClick = function (event) {
            var dropdown = _this.combobox.dropdown;
            var state = dropdown.initState();
            state.syntheticEvent = event;
            var oldValue = _this.value;
            var newValue = '';
            _this._suggested = '';
            _this.setValue(newValue);
            var focusedIndex = 0;
            if (_this.state.focusedIndex !== focusedIndex) {
                state.data.focusedIndex = focusedIndex;
            }
            if (oldValue !== newValue) {
                state.events.push({ type: 'onChange' });
            }
            if (_this.state.opened) {
                state.data.opened = false;
                state.events.push({ type: 'onClose' });
            }
            _this.forceUpdateIfNeeded(state);
            dropdown.applyState(state);
        };
        var opened = props.opened;
        var value = ((props.value !== undefined) ? props.value : props.defaultValue) || '';
        _this.state = {
            isFocused: opened,
            focusedIndex: opened ? _this.getFocusedIndex(value) : undefined,
            opened: opened
        };
        var dropdown = new DropDownBase_1.default(_this);
        _this.combobox = new ComboBoxBase_1.default(dropdown);
        dropdown.value = value;
        _this._inputId = kendo_react_common_1.guid();
        return _this;
    }
    Object.defineProperty(AutoComplete.prototype, "element", {
        /**
         * @hidden
         */
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoComplete.prototype, "value", {
        /**
         * Represents the value of the AutoComplete.
         */
        get: function () {
            return this.combobox.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    AutoComplete.prototype.componentWillReceiveProps = function (nextProps) {
        var dropdown = this.combobox.dropdown;
        var state = dropdown.initState();
        var nextValue = nextProps.value;
        var controlled = nextValue !== undefined;
        if (nextProps.opened !== undefined) {
            state.data.opened = nextProps.opened;
        }
        if (controlled) {
            dropdown.value = nextValue;
        }
        state.data.focusedIndex = this.getFocusedIndex(nextValue, nextProps.data);
        if (nextProps.suggest) {
            if (typeof nextProps.suggest === 'string') {
                this._suggested = nextProps.suggest;
            }
            else {
                this.suggestValue(dropdown.value);
            }
        }
        dropdown.applyState(state);
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.componentWillUpdate = function (_nextProps, nextState) {
        if (!this.state.opened && nextState.opened) {
            this.combobox.dropdown.calculatePopupWidth();
        }
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.componentDidUpdate = function (_prevProps, prevState) {
        var _a = this.state, opened = _a.opened, focusedIndex = _a.focusedIndex;
        var justOpened = !prevState.opened && opened;
        var focusedIndexChanged = focusedIndex !== undefined && prevState.focusedIndex !== focusedIndex;
        if ((opened && focusedIndexChanged) || justOpened) {
            this.combobox.dropdown.scrollToItem(focusedIndex);
        }
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.componentDidMount = function () {
        this.combobox.componentDidMount();
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.onNavigate = function (event) {
        var upOrDownArrows = event.keyCode === 38 /* up */ || event.keyCode === 40 /* down */;
        var _a = this.state, opened = _a.opened, focusedIndex = _a.focusedIndex;
        var typedText = this.value;
        if (!upOrDownArrows || (upOrDownArrows && (event.altKey || !opened))) {
            return;
        }
        var dropdown = this.combobox.dropdown;
        var _b = this.props.data, data = _b === void 0 ? [] : _b;
        var state = dropdown.initState();
        var focusedIndx = focusedIndex !== undefined ? focusedIndex :
            this.getFocusedIndex(typedText);
        dropdown.navigation.navigate({
            opened: opened,
            event: event,
            state: state,
            currentIndex: focusedIndx,
            max: data.length - 1,
            min: 0,
            leftRightKeysNavigation: false,
            togglePopup: this.togglePopup,
            handleItemSelect: this.itemFocus
        });
        state.syntheticEvent = event;
        dropdown.applyState(state);
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.render = function () {
        var _this = this;
        var _a = this.props, dir = _a.dir, disabled = _a.disabled, label = _a.label, className = _a.className, style = _a.style, loading = _a.loading;
        var isFocused = this.state.isFocused;
        var value = this.value;
        var renderClearButton = !loading && !!value;
        var dropdown = this.combobox.dropdown;
        var autoComplete = (React.createElement("span", { className: kendo_react_common_1.classNames('k-widget k-autocomplete k-header', className, { 'k-state-disabled': disabled, 'k-state-focused': isFocused && !disabled }), ref: function (element) {
                _this._element = element;
                dropdown.wrapper = element;
            }, style: !label
                ? style
                : __assign({}, style, { width: undefined }), dir: dir },
            this.renderSearchBar(renderClearButton, value),
            loading && React.createElement("span", { className: "k-icon k-i-loading" }),
            this.renderListContainer()));
        return label
            ? (React.createElement(kendo_react_common_1.FloatingLabel, { label: label, value: value, style: { width: style ? style.width : undefined }, id: this._inputId, children: autoComplete }))
            : autoComplete;
    };
    /**
     * @hidden
     */
    AutoComplete.prototype.applyInputValue = function (value, state, eventKey) {
        var opened = this.state.opened;
        var focusedIndex = this.state.focusedIndex !== undefined ?
            this.state.focusedIndex : this.getFocusedIndex(value);
        this._suggested = '';
        if (opened && eventKey === 13 /* enter */) {
            var newValue = util_1.getText(this.props, focusedIndex);
            this.setValue(newValue);
            if (value !== newValue) {
                state.events.push({ type: 'onChange' });
            }
        }
        if (this.state.focusedIndex !== focusedIndex) {
            state.data.focusedIndex = focusedIndex;
        }
        if (opened) {
            state.data.opened = false;
            state.events.push({ type: 'onClose' });
        }
        this.forceUpdateIfNeeded(state);
        this.combobox.dropdown.applyState(state);
    };
    AutoComplete.prototype.getFocusedIndex = function (value, data) {
        if (!value) {
            return 0;
        }
        var textField = this.props.textField;
        data = data || this.props.data || [];
        var selectedIndex = util_1.getItemIndexByText(data, value, textField, true);
        return selectedIndex !== -1 ? selectedIndex : util_1.itemIndexStartsWith(value, data, textField);
    };
    AutoComplete.prototype.renderSearchBar = function (clearButton, value) {
        var dropdown = this.combobox.dropdown;
        var _a = this.props, placeholder = _a.placeholder, tabIndex = _a.tabIndex, disabled = _a.disabled, readonly = _a.readonly, textField = _a.textField, _b = _a.data, data = _b === void 0 ? [] : _b;
        var _c = this.state, isFocused = _c.isFocused, opened = _c.opened;
        var selectedIndex = util_1.getItemIndexByText(data, value, textField, true);
        return (React.createElement(AutoCompleteSearchBar_1.default, { id: this._inputId, placeholder: placeholder, tabIndex: tabIndex || undefined, value: value, suggestedText: this._suggested, focused: isFocused, onKeyDown: this.combobox.onInputKeyDown, onChange: this.onChangeHandler, onFocus: this.combobox.handleFocus, onBlur: this.combobox.handleBlur, disabled: disabled, readOnly: readonly, expanded: opened, owns: dropdown.listBoxId, activedescendant: dropdown.optionPrefix + '-' + selectedIndex, clearButton: clearButton, clearButtonClick: this.clearButtonClick }));
    };
    AutoComplete.prototype.renderListContainer = function () {
        var _this = this;
        var dropdown = this.combobox.dropdown;
        var _a = this.props, dir = _a.dir, header = _a.header, footer = _a.footer;
        var popupSettings = dropdown.getPopupSettings();
        var opened = this.state.opened;
        return (React.createElement(ListContainer_1.default, { onMouseDown: function () {
                _this.combobox._lastMousedown = new Date().getTime();
            }, width: dropdown.popupWidth, popupSettings: {
                animate: popupSettings.animate,
                anchor: this.element || undefined,
                show: opened,
                className: 'k-list-container k-reset'
            }, dir: dir !== undefined ? dir : dropdown.dirCalculated },
            header,
            this.renderList(),
            footer));
    };
    AutoComplete.prototype.renderList = function () {
        var dropdown = this.combobox.dropdown;
        var popupSettings = dropdown.getPopupSettings();
        var _a = this.props, textField = _a.textField, _b = _a.data, data = _b === void 0 ? [] : _b, listNoDataRender = _a.listNoDataRender, itemRender = _a.itemRender;
        var _c = this.state, opened = _c.opened, focusedIndex = _c.focusedIndex;
        var value = this.value;
        return (React.createElement(List_1.default, { id: dropdown.listBoxId, show: opened, data: data.slice(), focusedIndex: focusedIndex, value: value, textField: textField, valueField: textField, highlightSelected: false, optionPrefix: dropdown.optionPrefix, listRef: function (element) {
                dropdown.list = element;
            }, wrapperStyle: { maxHeight: popupSettings.height }, wrapperCssClass: "k-list-scroller", onClick: dropdown.handleItemClick, itemRender: itemRender, noDataRender: listNoDataRender }));
    };
    AutoComplete.prototype.forceUpdateIfNeeded = function (state) {
        if (!this.controlled() && Object.keys(state.data).length === 0) {
            this.forceUpdate();
        }
    };
    AutoComplete.prototype.suggestValue = function (value) {
        this._suggested = '';
        if (value) {
            var _a = this.props, _b = _a.data, data = _b === void 0 ? [] : _b, textField = _a.textField;
            var suggestedItem = data[util_1.itemIndexStartsWith(value, data, textField)];
            if (suggestedItem) {
                var suggestedText = util_1.getItemText(suggestedItem, textField);
                if (value.toLowerCase() !== suggestedText.toLowerCase()) {
                    this._suggested = suggestedText.substring(value.length);
                }
            }
        }
    };
    AutoComplete.prototype.setValue = function (value) {
        var dropdown = this.combobox.dropdown;
        if (this.controlled()) {
            dropdown.valueDuringOnChange = value;
        }
        else {
            dropdown.value = value;
        }
    };
    AutoComplete.prototype.controlled = function () {
        return this.props.value !== undefined;
    };
    /**
     * @hidden
     */
    AutoComplete.propTypes = __assign({}, DropDownBase_1.default.basicPropTypes, { suggest: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]), placeholder: PropTypes.string, value: PropTypes.string, defaultValue: PropTypes.string, readonly: PropTypes.bool });
    /**
     * @hidden
     */
    AutoComplete.defaultProps = __assign({}, ComboBoxBase_1.default.defaultProps);
    return AutoComplete;
}(React.Component));
exports.default = AutoComplete;
//# sourceMappingURL=AutoComplete.js.map
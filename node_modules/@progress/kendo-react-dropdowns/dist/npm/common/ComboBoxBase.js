"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var DropDownBase_1 = require("../common/DropDownBase");
var SearchBar_1 = require("../common/SearchBar");
var List_1 = require("../common/List");
var ListContainer_1 = require("../common/ListContainer");
var util_1 = require("../common/util");
/**
 * @hidden
 */
var ComboBoxBase = /** @class */ (function () {
    function ComboBoxBase(dropdown) {
        var _this = this;
        this._lastMousedown = 0;
        this.handleItemSelect = function (index, state) {
            _this.dropdown.handleItemSelect(index, state);
            if (_this.dropdown.selectedItemChanged) {
                var component = _this.dropdown.component;
                if (component.state.typedText) {
                    state.data.typedText = '';
                }
                if (component.state.filterText) {
                    state.data.filterText = '';
                }
                if (component.state.suggestedText) {
                    component.state.suggestedText = '';
                }
            }
        };
        this.setValueSelection = function (value, text, selected, state) {
            if (value === void 0) { value = undefined; }
            if (text === void 0) { text = undefined; }
            if (selected === void 0) { selected = undefined; }
            var component = _this.dropdown.component;
            if (!component.props.filterable && text !== component.state.text) {
                state.data.text = text;
            }
            if (state.data.selectedIndex !== component.state.selectedIndex) {
                state.data.selectedIndex = selected;
                state.data.focusedIndex = selected !== -1 ? selected : undefined;
            }
            _this.dropdown.value = value;
        };
        this.onInputKeyDown = function (event) {
            var component = _this.dropdown.component;
            var keyCode = event.keyCode;
            var preventDefault = function () {
                if (component.state.opened) {
                    event.preventDefault();
                }
            };
            if (keyCode === 13 /* enter */ || keyCode === 27 /* esc */) {
                preventDefault();
                var value = event.currentTarget.value;
                var state = _this.dropdown.initState();
                state.syntheticEvent = event;
                component.applyInputValue(value, state, event.keyCode);
            }
            else if (keyCode === 38 /* up */ || keyCode === 40 /* down */) {
                preventDefault();
                _this.dropdown.handleKeyDown(event);
            }
        };
        this.onChangeHandler = function (event) {
            var component = _this.dropdown.component;
            var state = _this.dropdown.initState();
            var value = event.currentTarget.value;
            var controlled = component.props.value !== undefined;
            state.syntheticEvent = event;
            if (!value) {
                _this.clearValue(state, false);
                return _this.dropdown.applyState(state);
            }
            if (!component.state.opened) {
                state.data.opened = true;
            }
            state.data.typedText = value;
            if (!controlled) {
                state.data.selectedIndex = -1;
                _this.dropdown.index = -1;
            }
            if (component.props.filterable) {
                _this.dropdown.filterChanged(value, state);
            }
            if (component.state.opened === state.data.opened) {
                state.events.push({ type: state.data.opened ? 'onOpen' : 'onClose' });
            }
            _this.suggestValue(value, state);
            _this.dropdown.applyState(state);
        };
        this.handleBlur = function (event) {
            var component = _this.dropdown.component;
            if (component.state.isFocused) {
                var time = new Date().getTime();
                if (time - _this._lastMousedown < 500) {
                    _this._lastMousedown = 0;
                    return event.currentTarget.focus();
                }
                var state = _this.dropdown.initState();
                state.data.isFocused = false;
                state.events.push({ type: 'onBlur' });
                state.syntheticEvent = event;
                component.applyInputValue(event.currentTarget.value, state);
            }
        };
        this.handleFocus = function (event) {
            _this.dropdown.handleFocus(event);
        };
        this.clearButtonClick = function (event) {
            var component = _this.dropdown.component;
            var state = _this.dropdown.initState();
            state.syntheticEvent = event;
            _this.clearValue(state);
            if (component.state.opened) {
                _this.dropdown.togglePopup(state);
            }
            _this.dropdown.applyState(state);
        };
        this.togglePopup = function (state) {
            _this.dropdown.togglePopup(state);
        };
        this.dropdown = dropdown;
    }
    Object.defineProperty(ComboBoxBase.prototype, "value", {
        get: function () {
            return this.dropdown.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxBase.prototype, "index", {
        get: function () {
            return this.dropdown.index;
        },
        enumerable: true,
        configurable: true
    });
    ComboBoxBase.prototype.componentWillReceiveProps = function (nextProps) {
        this.dropdown.componentWillReceiveProps(nextProps);
    };
    ComboBoxBase.prototype.componentWillUpdate = function (nextProps, nextState) {
        this.dropdown.componentWillUpdate(nextProps, nextState);
        var component = this.dropdown.component;
        if (!component.state.opened && nextState.opened) {
            this.dropdown.calculatePopupWidth();
        }
        var indexChanged = nextState.selectedIndex !== undefined &&
            component.state.selectedIndex !== nextState.selectedIndex;
        var prevTypedText = component.state.typedText;
        var typedText = nextState.typedText;
        var typedTextChanged = (typedText !== undefined && typedText !== prevTypedText) ||
            (!typedText && prevTypedText && this.dropdown.lastValueSelected === undefined);
        if (indexChanged) {
            var newItem = (nextProps.data || [])[(nextState.selectedIndex || 0) - (nextState.skip || 0)];
            this.dropdown.value = util_1.getItemValue(newItem, nextProps.valueField);
            this.dropdown.text = util_1.getItemText(newItem, nextProps.textField);
            this.dropdown.index = nextState.selectedIndex || 0;
        }
        else if (typedTextChanged) {
            this.dropdown.lastTextSelected = '';
            this.dropdown.lastValueSelected = undefined;
            if (this.dropdown.value !== null && this.dropdown.value !== '') {
                this.dropdown.value = undefined;
            }
            this.dropdown.index = -1;
            this.dropdown.text = '';
        }
    };
    ComboBoxBase.prototype.componentDidUpdate = function (prevState) {
        var dropdown = this.dropdown;
        dropdown.componentDidUpdate(prevState);
        var component = dropdown.component;
        var _a = component.state, typedText = _a.typedText, opened = _a.opened, focusedIndex = _a.focusedIndex;
        if (opened && (typedText !== prevState.typedText || prevState.focusedIndex !== focusedIndex)) {
            var focusedIdx = this.getFocusedIndex(typedText);
            if (focusedIdx !== -1) {
                dropdown.scrollToItem(focusedIdx - (component.state.skip || 0));
            }
        }
    };
    ComboBoxBase.prototype.componentDidMount = function () {
        this.dropdown.componentDidMount();
    };
    ComboBoxBase.prototype.componentWillUnmount = function () {
        this.dropdown.componentWillUnmount();
    };
    ComboBoxBase.prototype.onNavigate = function (event) {
        var component = this.dropdown.component;
        var _a = component.props, _b = _a.data, data = _b === void 0 ? [] : _b, filterable = _a.filterable, textField = _a.textField;
        var state = this.dropdown.initState();
        var vs = this.dropdown.vs;
        var index = util_1.getItemIndex(component.props, component.value);
        var text = component.state.typedText;
        var currentIndex = vs.skip + index;
        if (currentIndex < 0 && text && (event.keyCode === 38 /* up */ || event.keyCode === 40 /* down */)) {
            var focusedIndex = util_1.itemIndexStartsWith(text, data, textField);
            if (focusedIndex >= 0) {
                currentIndex = event.keyCode === 38 /* up */ ? focusedIndex + 1 : focusedIndex - 1;
            }
        }
        this.dropdown.navigation.navigate({
            opened: component.state.opened,
            event: event,
            state: state,
            currentIndex: currentIndex,
            max: (vs.enabled ? vs.total : data.length) - 1,
            min: 0,
            leftRightKeysNavigation: filterable,
            togglePopup: component.togglePopup,
            handleItemSelect: this.handleItemSelect
        });
        state.syntheticEvent = event;
        this.dropdown.applyState(state);
    };
    ComboBoxBase.prototype.valueToRender = function (state, props) {
        var component = this.dropdown.component;
        var _a = state || component.state, _b = _a.typedText, typedText = _b === void 0 ? '' : _b, _c = _a.filterText, filterText = _c === void 0 ? '' : _c, selectedIndex = _a.selectedIndex;
        var _d = props || component.props, value = _d.value, filterable = _d.filterable, textField = _d.textField, valueField = _d.valueField, _e = _d.data, data = _e === void 0 ? [] : _e;
        var controlled = value !== undefined;
        var resultText = this.dropdown.text || '';
        var resultValue = controlled ? value : this.dropdown.value;
        var hasFilter = filterable && !!filterText;
        var itemSelected = !typedText && selectedIndex !== -1;
        if (hasFilter) {
            return { value: null, text: filterText };
        }
        else if (!itemSelected) {
            var typedTextMatchIndex = util_1.getItemIndexByText(data, typedText, textField);
            if (typedTextMatchIndex === -1) {
                return { value: null, text: typedText };
            }
            else {
                return { value: util_1.getItemValue(data[typedTextMatchIndex], valueField), text: typedText };
            }
        }
        return { value: resultValue, text: resultText };
    };
    ComboBoxBase.prototype.getFocusedIndex = function (text) {
        var component = this.dropdown.component;
        var _a = component.state, opened = _a.opened, skip = _a.skip, focusedIndex = _a.focusedIndex;
        var _b = component.props, textField = _b.textField, _c = _b.data, data = _c === void 0 ? [] : _c;
        if (opened) {
            if (focusedIndex !== undefined) {
                return focusedIndex;
            }
            else if (text) {
                return util_1.itemIndexStartsWith(text, data, textField);
            }
            else {
                return (skip === 0 ? 0 : -1);
            }
        }
        return -1;
    };
    ComboBoxBase.prototype.applyValueOnEnter = function (value, state) {
        var dropdown = this.dropdown;
        var component = dropdown.component;
        var _a = component.state.suggestedText, suggestedText = _a === void 0 ? '' : _a;
        var _b = component.props, _c = _b.data, data = _c === void 0 ? [] : _c, textField = _b.textField, valueField = _b.valueField, suggest = _b.suggest, allowCustom = _b.allowCustom;
        var valueIndex = util_1.getItemIndexByText(data, value, textField);
        var itemSelected = valueIndex !== -1;
        var newValue = undefined;
        var newText = '';
        if (suggest && suggestedText) { // item is suggested
            newText = newValue = suggestedText;
            state.data.typedText = suggestedText;
        }
        else if (itemSelected) { // typed text match item from list
            newValue = util_1.getItemValue(data[valueIndex], valueField);
            newText = util_1.getItemText(data[valueIndex], textField);
        }
        else {
            if (allowCustom) { // any custom text not in list
                newValue = value;
                newText = value;
            }
            else {
                return this.selectFocusedItem(value, state);
            }
        }
        if (dropdown.previousValue !== newValue) {
            state.events.push({ type: 'onChange' });
        }
        this.closePopup(state);
        dropdown.value = newValue;
        dropdown.text = newText;
        dropdown.applyState(state);
    };
    ComboBoxBase.prototype.closePopup = function (state) {
        if (this.dropdown.component.state.opened) {
            state.data.opened = false;
            state.events.push({ type: 'onClose' });
        }
    };
    ComboBoxBase.prototype.applyValueOnRejectSuggestions = function (value, state) {
        var dropdown = this.dropdown;
        var component = dropdown.component;
        var _a = component.props, _b = _a.data, data = _b === void 0 ? [] : _b, textField = _a.textField, valueField = _a.valueField, allowCustom = _a.allowCustom;
        var valueIndex = util_1.getItemIndexByText(data, value, textField, true);
        var itemSelected = valueIndex !== -1;
        var newValue = undefined;
        var newText = '';
        if (component.state.suggestedText) {
            state.data.suggestedText = undefined;
        }
        if (!itemSelected && !allowCustom && value && value === dropdown.lastTextSelected) {
            newValue = dropdown.lastValueSelected;
            newText = dropdown.lastTextSelected;
        }
        else if (!itemSelected && !allowCustom && value === component.state.typedText) {
            this.clearValue(state);
            this.closePopup(state);
            return dropdown.applyState(state);
        }
        else if (itemSelected) { // typed text match item from list
            newValue = util_1.getItemValue(data[valueIndex], valueField);
            newText = value;
        }
        else {
            if (allowCustom) { // any custom text not in list
                newValue = value || undefined;
                newText = value;
            }
            else {
                return this.selectFocusedItem(value, state);
            }
        }
        if (dropdown.previousValue !== newValue) {
            state.events.push({ type: 'onChange' });
            dropdown.value = newValue;
        }
        dropdown.text = newText;
        this.closePopup(state);
        dropdown.applyState(state);
    };
    ComboBoxBase.prototype.selectFocusedItem = function (value, state) {
        var dropdown = this.dropdown;
        var component = dropdown.component;
        var _a = component.state, _b = _a.skip, skip = _b === void 0 ? 0 : _b, opened = _a.opened;
        var _c = component.props, filterable = _c.filterable, _d = _c.data, data = _d === void 0 ? [] : _d, textField = _c.textField;
        var focusedItemIndex = util_1.itemIndexStartsWith(value, data, textField);
        if (focusedItemIndex !== -1) {
            this.handleItemSelect(focusedItemIndex + skip, state);
        }
        if (opened) {
            state.data.opened = false;
            state.events.push({ type: 'onClose' });
        }
        if (component.state.typedText) {
            state.data.typedText = '';
        }
        if (filterable) {
            state.data.filterText = dropdown.text;
        }
        return dropdown.applyState(state);
    };
    ComboBoxBase.prototype.applyInputValue = function (value, state, eventKey) {
        if (eventKey === 13 /* enter */) {
            return this.applyValueOnEnter(value, state);
        }
        else {
            return this.applyValueOnRejectSuggestions(value, state);
        }
    };
    ComboBoxBase.prototype.clearValue = function (state, triggerChange) {
        if (triggerChange === void 0) { triggerChange = true; }
        var component = this.dropdown.component;
        var controlled = component.props.value !== undefined;
        var oldValue = this.dropdown.previousValue;
        var newValue = null;
        var newText = '';
        var newIndex = -1;
        if (triggerChange && controlled) {
            this.dropdown.valueDuringOnChange = newValue;
            this.dropdown.indexDuringOnChange = newIndex;
        }
        else {
            this.dropdown.value = newValue;
            this.dropdown.index = newIndex;
            this.dropdown.text = newText;
            state.data.selectedIndex = newIndex;
        }
        state.data.typedText = '';
        if (component.state.focusedIndex !== undefined) {
            state.data.focusedIndex = undefined;
        }
        if (component.state.suggestedText !== undefined) {
            state.data.suggestedText = undefined;
        }
        if (triggerChange && oldValue !== undefined && oldValue !== null) {
            state.events.push({ type: 'onChange' });
            this.dropdown.selectedItemChanged = true;
        }
        if (component.props.filterable) {
            this.dropdown.filterChanged(newText, state);
            this.dropdown.vs.reset();
        }
    };
    ComboBoxBase.prototype.suggestValue = function (value, state) {
        var component = this.dropdown.component;
        if (component.state.suggestedText !== undefined) {
            state.data.suggestedText = undefined;
        }
        if (component.props.suggest && value) {
            var data = component.props.data || [];
            var textField = component.props.textField;
            var suggestedItem = data[util_1.itemIndexStartsWith(value, data, textField)];
            if (suggestedItem) {
                state.data.suggestedText = util_1.getItemText(suggestedItem, textField);
            }
        }
    };
    // Common rendering
    ComboBoxBase.prototype.renderListContainer = function () {
        var _this = this;
        var dropdown = this.dropdown;
        var component = dropdown.component;
        var vs = dropdown.vs;
        var _a = component.props, dir = _a.dir, header = _a.header, footer = _a.footer;
        var opened = component.state.opened;
        var popupSettings = dropdown.getPopupSettings();
        return (React.createElement(ListContainer_1.default, { onMouseDown: function () {
                _this._lastMousedown = new Date().getTime();
            }, width: dropdown.popupWidth, popupSettings: {
                animate: popupSettings.animate,
                anchor: component.element || undefined,
                show: opened,
                open: function () {
                    vs.hidden = false;
                },
                className: 'k-list-container k-reset',
                close: function () {
                    vs.hidden = true;
                }
            }, dir: dir !== undefined ? dir : dropdown.dirCalculated },
            header,
            dropdown.renderScrollWrapper([
                this.renderList(),
                dropdown.renderScrollElement()
            ]),
            footer));
    };
    ComboBoxBase.prototype.renderSearchBar = function (clearButton, text, id) {
        var component = this.dropdown.component;
        var _a = component.props, placeholder = _a.placeholder, tabIndex = _a.tabIndex, disabled = _a.disabled;
        var _b = component.state, suggestedText = _b.suggestedText, isFocused = _b.isFocused, opened = _b.opened, _c = _b.selectedIndex, selectedIndex = _c === void 0 ? 0 : _c;
        return (React.createElement(SearchBar_1.default, { id: id, placeholder: placeholder, tabIndex: tabIndex || undefined, value: text, suggestedText: suggestedText, focused: isFocused, onKeyDown: this.onInputKeyDown, onChange: this.onChangeHandler, onFocus: this.handleFocus, onBlur: this.handleBlur, disabled: disabled, expanded: opened, owns: this.dropdown.listBoxId, activedescendant: this.dropdown.optionPrefix + '-' + selectedIndex, clearButton: clearButton, clearButtonClick: this.clearButtonClick }));
    };
    ComboBoxBase.prototype.renderList = function () {
        var dropdown = this.dropdown;
        var component = dropdown.component;
        var _a = component.props, textField = _a.textField, valueField = _a.valueField, listNoDataRender = _a.listNoDataRender, itemRender = _a.itemRender;
        var popupSettings = dropdown.getPopupSettings();
        var vs = dropdown.vs;
        var _b = component.state, opened = _b.opened, _c = _b.skip, skip = _c === void 0 ? 0 : _c;
        var translate = "translateY(" + vs.translate + "px)";
        var _d = this.valueToRender(), value = _d.value, text = _d.text;
        var data = (component.props.data || []).slice();
        var focusedIndex;
        if (opened) {
            focusedIndex = this.getFocusedIndex(text) - skip;
        }
        return (React.createElement(List_1.default, { id: dropdown.listBoxId, show: opened, data: data, focusedIndex: focusedIndex, value: value, textField: textField, valueField: valueField, optionPrefix: dropdown.optionPrefix, listRef: function (element) {
                if (vs.enabled) {
                    vs.list = element;
                }
                dropdown.list = element;
            }, wrapperStyle: !vs.enabled ?
                { maxHeight: popupSettings.height } : { float: 'left', width: '100%' }, wrapperCssClass: !vs.enabled ? 'k-list-scroller' : undefined, listStyle: vs.enabled ?
                { transform: translate } : undefined, key: 1, skip: skip, onClick: this.dropdown.handleItemClick, itemRender: itemRender, noDataRender: listNoDataRender }));
    };
    ComboBoxBase.propTypes = __assign({}, DropDownBase_1.default.propTypes, { suggest: PropTypes.bool, placeholder: PropTypes.string });
    ComboBoxBase.defaultProps = __assign({}, DropDownBase_1.default.defaultProps);
    return ComboBoxBase;
}());
exports.default = ComboBoxBase;
//# sourceMappingURL=ComboBoxBase.js.map